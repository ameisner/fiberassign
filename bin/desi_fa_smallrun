#!/usr/bin/env python

import os
import sys
from glob import glob
import numpy as np
import astropy.io.fits as fits
from astropy.table import Table
import fitsio
from astropy import units
from astropy.coordinates import SkyCoord
from desitarget.targetmask import obsconditions
from desitarget.targets import encode_targetid
from desitarget.io import read_targets_in_tiles
from desitarget.mtl import make_mtl, calc_priority
from fiberassign.scripts.assign import parse_assign, run_assign_full
from fiberassign.scripts.merge import parse_merge, run_merge
from desimodel.footprint import is_point_in_desi, tiles2pix
from desiutil.redirect import stdouterr_redirected
import healpy as hp
from desitarget.internal import sharedmem
from argparse import ArgumentParser

# AR list of priorities (ELG=3000, LRG=3200, QSO=3400)
# https://github.com/desihub/desitarget/blob/master/py/desitarget/data/targetmask.yaml#L186-L223
# https://github.com/desihub/desitarget/blob/master/py/desitarget/sv1/data/sv1_targetmask.yaml#L251-L324
# https://github.com/desihub/desitarget/blob/master/py/desitarget/sv2/data/sv2_targetmask.yaml#L152-L189


# AR created file names
def get_fn(outdir, flavor, passid=None):
    # AR flavor = settings, log, tiles, sky, targ, fastats-targ, fastats-sky
    # AR pass = passid
    if passid is not None:
        if flavor == "tiles":
            fn = os.path.join(
                outdir,
                "faruns",
                "farun-pass{}".format(passid),
                "{}-pass{}.fits".format(flavor, passid),
            )
        if flavor == "targ":
            fn = os.path.join(
                outdir, "outputs", "{}-after-pass{}.fits".format(flavor, passid)
            )
    elif flavor == "settings":
        fn = os.path.join(args.outdir, "inputs", "settings.asc")
    elif flavor == "log":
        fn = os.path.join(args.outdir, "outputs", "file.log")
    elif flavor in ["fastats-targ", "fastats-sky", "fastats-pairs"]:
        fn = os.path.join(outdir, "outputs", "{}.asc".format(flavor))
    else:
        fn = os.path.join(outdir, "inputs", "{}.fits".format(flavor))
    return fn


# AR get matching index for two np arrays, those should be arrays with unique values, like id
# AR https://stackoverflow.com/questions/32653441/find-indices-of-common-values-in-two-arrays
# AR we get: A[maskA] = B[maskB]
def unq_searchsorted(A, B):
    # AR sorting A,B
    tmpA = np.sort(A)
    tmpB = np.sort(B)
    # AR create mask equivalent to np.in1d(A,B) and np.in1d(B,A) for unique elements
    maskA = (
        np.searchsorted(tmpB, tmpA, "right") - np.searchsorted(tmpB, tmpA, "left")
    ) == 1
    maskB = (
        np.searchsorted(tmpA, tmpB, "right") - np.searchsorted(tmpA, tmpB, "left")
    ) == 1
    # AR to get back to original indexes
    return np.argsort(A)[maskA], np.argsort(B)[maskB]


# AR creates one tiles file for with all passes
# AR and one tiles file per pass
def create_tiles(infn, program, radec, outdir):
    h = fits.open(infn)
    d = h[1].data
    # AR gray2dark?
    if args.gray2dark == "y":
        keep = d["PROGRAM"].upper() == "GRAY"
        d["PROGRAM"][keep] = "DARK"
        d["OBSCONDITIONS"][keep] = obsconditions.mask("DARK")
    # AR cut on IN_DESI
    is_indesi = d["IN_DESI"] == 1
    # AR cut on radec
    ramin, ramax, decmin, decmax = [float(x) for x in radec.split(",")]
    is_radec = (d["DEC"] > decmin) & (d["DEC"] < decmax)
    if ramax < ramin:
        is_radec &= (d["RA"] > ramin) | (d["RA"] < ramax)
    else:
        is_radec &= (d["RA"] > ramin) & (d["RA"] < ramax)
    # AR cut on program
    is_prog = d["PROGRAM"].lower() == program
    # AR cut on the number of passes
    # AR first pass is 0
    # AR with 4112packing-2021-03-28, bright and backup
    # AR also start at pass=0
    if args.npass > d["PASS"][is_prog].max() + 1:
        print(
            "WARNING : requesting {} passes, whereas only {} passes available".format(
                args.npass, d["PASS"][is_prog].max() + 1
            )
        )
    is_pass = d["PASS"] + 1 <= args.npass
    # AR writing one tiles file with all passes
    keep = (is_indesi) & (is_radec) & (is_prog) & (is_pass)
    h[1].data = h[1].data[keep]
    h.writeto(get_fn(args.outdir, "tiles"), overwrite=True)
    # AR writing one tiles file for each pass
    passids = np.unique(d["PASS"][keep])
    for passid in passids:
        h = fits.open(infn)
        keep_p = (keep) & (d["PASS"] == passid)
        print("pass = {} -> {} tiles".format(passid, keep_p.sum()))
        h[1].data = h[1].data[keep_p]
        fadir = os.path.join(args.outdir, "faruns", "farun-pass{}".format(passid))
        if not os.path.isdir(fadir):
            os.mkdir(fadir)
        h.writeto(get_fn(args.outdir, "tiles", passid=passid), overwrite=True)
    return True


# AR wrapper to read targets
def wrapper_read_targets():
    if args.dtver in ["0.54.0.dev4695", "0.55.0.dev4725"]:
        hpdir = os.path.join(
            "/global/cscratch1/sd/adamyers/dr9",
            args.dtver,
            "targets",
            args.survey,
            "resolve",
            args.program,
        )
    else:
        hpdir = os.path.join(
            os.getenv("DESI_TARGET"),
            "catalogs",
            args.dr,
            args.dtver,
            "targets",                                                                                                                                         
            args.survey,
            "resolve",
            args.program,
        )
    # AR we only store some columns...
    columns = ["TARGETID", "RA", "DEC"]
    columns += [dtkey, dtkey.replace("DESI", "BGS"), dtkey.replace("DESI", "MWS")]
    columns += [
        "PHOTSYS",
        "SUBPRIORITY",
        "OBSCONDITIONS",
        "PRIORITY_INIT",
        "NUMOBS_INIT",
    ]
    for band in ["G", "R", "Z", "W1", "W2"]:
        columns += ["FLUX_{}".format(band), "MW_TRANSMISSION_{}".format(band)]
        if band in ["G", "R", "Z"]:
            columns += ["FIBERFLUX_{}".format(band)]
    d = read_targets_in_tiles(hpdir, tiles, columns=columns, quick=True)
    # AR remove bgs from dark program?
    # AR we identify bgs-only from the priority
    if args.rmvdarkbgs == "y":
        keep = (d["PRIORITY_INIT"] != 2000) & (d["PRIORITY_INIT"] != 2100)
        d = d[keep]
    return d


# AR wrapper to read randoms
def wrapper_read_randoms():
    tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
    # AR all sky 2500/deg2 random file
    fn = os.path.join(os.getenv("DESI_ROOT"), "target/catalogs/dr9/0.49.0/randoms/resolve/randoms-allsky-1-0.fits")
    # AR healpix settings
    from astropy.time import Time
    print(Time.now(), "start")
    hdr = fits.getheader(fn, 1)
    nside, nest = hdr["HPXNSIDE"], hdr["HPXNEST"]
    rand_dens = hdr["DENSITY"]
    # AR hp pixels touching the tiles
    pixlist = tiles2pix(nside, tiles=tiles)
    # AR reading the hpxpixel
    d = fitsio.read(fn, columns=["HPXPIXEL"])
    print(Time.now(), "first read done")
    # AR cutting on rands touching pixlist
    rows = np.where(np.in1d(d["HPXPIXEL"], pixlist))[0]
    d = fitsio.read(fn, columns=["RA", "DEC", "BRICKID"], rows=rows)
    print(Time.now(), "second read done")
    # AR properly cutting on the tiles footprint
    keep = is_point_in_desi(tiles, d["RA"], d["DEC"])
    d = d[keep]
    ras, decs, brickids = d["RA"], d["DEC"], d["BRICKID"]
    nrand = len(ras)
    # AR creating fake columns
    print(Time.now(), "start build table")
    d = Table()
    d["TARGETID"] = encode_targetid(objid=np.arange(nrand), brickid=brickids)
    d["RA"], d["DEC"] = ras, decs
    d[dtkey] = np.zeros(nrand, dtype=int) + desi_mask["ELG"] # AR making them ELGs
    d[dtkey.replace("DESI", "BGS")] = np.zeros(nrand, dtype=int)
    d[dtkey.replace("DESI", "MWS")] = np.zeros(nrand, dtype=int)
    d["PRIORITY_INIT"] = np.zeros(nrand, dtype=int) + desi_mask["ELG"].priorities["UNOBS"]
    d["SUBPRIORITY"] = np.random.uniform(low=0, high=1, size=nrand)
    d["NUMOBS_INIT"] = np.ones(nrand, dtype=int)
    d["OBSCONDITIONS"] = np.array([args.program.upper() for x in ras])
    print(Time.now(), "done")
    return d, rand_dens


# AR randomly assigns QSO to be Lya
def set_lya(d, lyafrac):
    ii_qso = np.where((d[dtkey] & desi_mask["QSO"]) > 0)[0]
    ii_lya = np.random.choice(ii_qso, size=int(lyafrac * len(ii_qso)), replace=False)
    return np.in1d(np.arange(len(d), dtype=int), ii_lya)


# AR tweak PRIORITY_INIT and PRIORITY
def tweak_priority(d, priority_mask, priority_frac, priority_new):
    # AR to store the targets with tweaked priority
    ii_used = []
    for pm, pf, pn in zip(
        priority_mask.split(","), priority_frac.split(","), priority_new.split(",")
    ):
        ii = np.where((d[dtkey] & desi_mask[pm]) > 0)[0]
        n_tweak = int(len(ii) * float(pf))
        ii_avail = ii[~np.in1d(ii, ii_used)]
        if len(ii_avail) < n_tweak:
            sys.exit(
                "cannot force {}/{} {} targets to PRIORITY={}; exiting".format(
                    n_tweak, len(ii_avail), pm, pn
                )
            )
        print(
            "forcing {}/{} {} targets to PRIORITY={}".format(
                n_tweak, len(ii_avail), pm, pn
            )
        )
        ii_tweak = np.random.choice(ii_avail, size=n_tweak, replace=False)
        d["PRIORITY_INIT"][ii_tweak] = np.clip(
            d["PRIORITY_INIT"][ii_tweak], int(pn), None
        )
        d["PRIORITY"][ii_tweak] = np.clip(d["PRIORITY"][ii_tweak], int(pn), None)
        ii_used += ii_tweak.tolist()
    return d


# AR internal function to run fiber assignment
# AR on a tile, when args.numproc > 1
# AR uses global variables:
# AR - sky_ra, sky_dec : input sky coordinates
# AR - targ_ra, targ_dec : input target coordinates
def _do_run_assign_full(intargfn_fadir_footfn_skyfn_targfn):
    global sky_ra, sky_dec
    global targ_ra, targ_dec
    # AR decode folder/filenames
    intargfn, fadir, footfn, skyfn, targfn = intargfn_fadir_footfn_skyfn_targfn.split(
        ","
    )
    # AR sky
    ii = np.where(is_point_in_desi(fits.open(footfn)[1].data, sky_ra, sky_dec))[0]
    d = fitsio.read(get_fn(args.outdir, "sky"), rows=ii)
    fitsio.write(skyfn, d, clobber=True)
    # AR targ
    ii = np.where(is_point_in_desi(fits.open(footfn)[1].data, targ_ra, targ_dec))[0]
    d = fitsio.read(intargfn, rows=ii)
    fitsio.write(targfn, d, clobber=True)
    # AR run fiber assignment
    opts = [
        "--rundate",
        args.rundate,
        "--overwrite",
        "--write_all_targets",
        "--footprint",
        footfn,
        "--dir",
        fadir,
        "--sky",
        skyfn,
        "--targets",
        targfn,
        "--sky_per_petal",
        args.sky_per_petal,
        "--standards_per_petal",
        args.standards_per_petal,
    ]
    print("run_assign_full for {}...".format(targfn))
    ag = parse_assign(opts)
    run_assign_full(ag)
    # AR clean input files
    for fn in [footfn, skyfn, targfn]:
        os.remove(fn)
    return True


# AR update the catalogs after having run fa + stats
def update_after_farun(input_targ, fadir, passid, output_targ):
    # fba files
    fns = np.sort(glob(os.path.join(fadir, "fba-??????.fits")))
    # reading targ which received a fibre, targ available
    # std, sky
    samples = ["targ", "targets", "potential", "sky"]
    extnames = ["FASSIGN", "FTARGETS", "FAVAIL", "FASSIGN"]
    myd = {}
    myh = {}
    for sample in samples:
        myd[sample] = {}
        myh[sample] = {}
    for fn in fns:
        print(fn)
        h = fits.open(fn)
        for sample, extname in zip(samples, extnames):
            # AR initialization
            if fn == fns[0]:
                myh[sample]["keys"] = ["TILEID"] + h[extname].columns.names
                myh[sample]["fmts"] = ["J"] + h[extname].columns.formats
                for key in myh[sample]["keys"]:
                    myd[sample][key] = []
            # AR appending (using bitwise)
            if sample in ["targ", "targets"]:
                keep = (h[extname].data["FA_TYPE"] & 1) > 0
            elif sample == "sky":
                keep = (h[extname].data["FA_TYPE"] & 4) > 0
            elif sample == "potential":
                keep = np.ones(len(h[extname].data), dtype=bool)
            else:
                sys.exit("wrong sample! exiting")
            for key in myh[sample]["keys"]:
                if key == "TILEID":
                    myd[sample][key] += [
                        h[1].header["TILEID"] for x in range(keep.sum())
                    ]
                else:
                    myd[sample][key] += h[extname].data[key][keep].tolist()
    # AR writing targ/targets/potential/sky
    for sample in samples:
        collist = []
        for key, fmt in zip(myh[sample]["keys"], myh[sample]["fmts"]):
            collist.append(fits.Column(name=key, format=fmt, array=myd[sample][key]))
        h = fits.BinTableHDU.from_columns(fits.ColDefs(collist))
        h.writeto(
            os.path.join(fadir, "fba-{}-pass{}.fits".format(sample, passid)),
            overwrite=True,
        )
    # AR input TARGETID, NUMOBS_MORE, NUMOBS_DONE
    h = fits.open(input_targ)
    tids = np.array(myd["targ"]["TARGETID"])
    tids, counts = np.unique(tids, return_counts=True)
    ii0, ii1 = unq_searchsorted(h[1].data["TARGETID"], tids)
    # AR updating numobs_more
    h[1].data["NUMOBS_MORE"][ii0] -= counts[ii1]
    h[1].data["NUMOBS_MORE"] = np.clip(h[1].data["NUMOBS_MORE"], 0, None)
    # AR updating numobs
    h[1].data["NUMOBS"][ii0] += counts[ii1]
    # AR updating NUMOBS_DONE
    h[1].data["NUMOBS_DONE"][ii0, passid] = counts[ii1]
    # AR updating Lya
    # AR QSO observed in passid which are not Lya
    keep = (
        ((h[1].data[dtkey] & desi_mask["QSO"]) > 0)
        & (h[1].data["NUMOBS_DONE"][:, passid] > 0)
        & (~h[1].data["ISLYA"])
    )
    h[1].data["NUMOBS_MORE"][keep] = 0
    # AR emulate mtl update?
    # AR if yes, updates: Z, ZWARN, ZTILEID, PRIORITY, TARGET_STATE
    if args.mtl_update == "y":
        # AR fake ztargets table, cf. make_mtl()
        # AR in make_mtl(): targets => h[1].data here
        n1 = len(ii1)
        ztargets = Table()
        ztargets["TARGETID"] = tids[ii1]
        ztargets["NUMOBS"] = counts[ii1]
        # AR 0 < Z < 2
        ztargets["Z"] = np.random.uniform(low=0, high=2.0, size=n1)
        # AR 2.1 < Z < 5 for Lya
        ztargets["Z"][h[1].data["ISLYA"][ii0]] = np.random.uniform(
            low=2.1, high=5, size=h[1].data["ISLYA"][ii0].sum()
        )
        ztargets["ZWARN"] = np.zeros(n1, dtype=np.int32)
        ztargets["ZTILEID"] = 1 * np.ones(n1, dtype=np.int32)
        ztargets["NUMOBS_MORE"] = h[1].data["NUMOBS_MORE"][ii0]  # AR added
        zmatcher = ii0.copy()
        # ADM extract just the targets that match the input zcat.
        targets_zmatcher = h[1].data[zmatcher]
        # ADM assign priorities. Only things in the zcat can have changed
        # ADM priorities. Anything else is assigned PRIORITY_INIT, below.
        priority, target_state = calc_priority(
            targets_zmatcher, ztargets, args.program.upper(), state=True
        )
        # ADM now populate the new mtl columns with the updated information.
        h[1].data["PRIORITY"][zmatcher] = priority
        h[1].data["TARGET_STATE"][zmatcher] = target_state
        for col in ["Z", "ZWARN", "ZTILEID"]:
            h[1].data[col][zmatcher] = ztargets[col]
    # AR change priority of observed Lya?
    if args.priority_lya is not None:
        keep = (h[1].data["ISLYA"]) & (h[1].data["NUMOBS_DONE"][:, passid] > 0)
        h[1].data["PRIORITY"][keep] = args.priority_lya
    # AR nfiber_avail, ntile_avail
    for sample, key in zip(["potential", "targets"], ["NFIBER_AVAIL", "NTILE_AVAIL"]):
        tids = np.array(myd[sample]["TARGETID"])
        tids, counts = np.unique(tids, return_counts=True)
        ii0, ii1 = unq_searchsorted(h[1].data["TARGETID"], tids)
        h[1].data[key][ii0, passid] = counts[ii1]
    # writing output
    h.writeto(output_targ, overwrite=True)
    return True


# AR selects object inside a "box" with a given margin in degrees
# AR cuts in Dec.: decmin + margin < dec < decmax - margin
# AR cuts in R.A.: accounts for the cos(Dec.) term with a 1-deg grid in Dec.
def sel_margin(ras, decs, radec, margin):
    ramin, ramax, decmin, decmax = [float(x) for x in radec.split(",")]
    keep = (decs > decmin + margin) & (decs < decmax - margin)
    ra_margins = margin / np.cos(np.radians(decs))
    if ramax < ramin:
        reject_ramin = (ras > ramin) & (ras < ramin + ra_margins)
        reject_ramax = (ras < ramax) & (ras > ramax - ra_margins)
    else:
        reject_ramin = ras < ramin + ra_margins
        reject_ramax = ras > ramax - ra_margins
    keep[(reject_ramin) | (reject_ramax)] = False
    return keep


# AR get the tile area and the safe "box" area
# AR picking one pixweight file
# AR we just want the fracarea here
def get_area(radec, tiles, margin):
    if args.dr == "dr8":
        fn = "{}/targets/catalogs/dr8/0.31.1/pixweight/pixweight-dr8-0.31.1.fits".format(
            os.getenv("DESI_ROOT")
        )
    if args.dr == "dr9":
        fn = "{}/target/catalogs/dr9/0.47.0/pixweight/main/resolve/dark/pixweight-dark.fits".format(
            os.getenv("DESI_ROOT")
        )
    h = fits.open(fn)
    nside, nest = h[1].header["HPXNSIDE"], h[1].header["HPXNEST"]
    theta, phi = hp.pix2ang(nside, np.arange(hp.nside2npix(nside)), nest=nest)
    ras, decs = 180.0 / np.pi * phi, 90.0 - 180.0 / np.pi * theta
    # AR cutting on tiles
    keep = is_point_in_desi(tiles, ras, decs)
    area_tile = np.round(
        h[1].data["FRACAREA"][keep].sum() * hp.nside2pixarea(nside, degrees=True), 0
    )
    # AR further cutting on margins
    keep &= sel_margin(ras, decs, radec, margin)
    area_safe = np.round(
        h[1].data["FRACAREA"][keep].sum() * hp.nside2pixarea(nside, degrees=True), 0
    )
    return area_tile, area_safe


# AR select tracers
def sel_tracer(d, tracer):
    if tracer == "ALL":
        return np.ones(len(d), dtype=bool)
    elif tracer == "LYA":
        return ((d[dtkey] & desi_mask["QSO"]) > 0) & (d["ISLYA"])
    else:
        return (d[dtkey] & desi_mask[tracer]) > 0


# AR fastats-targ
# AR ! should be run on a region excluding the edges !
def fastats_targ(tracers, targ_fn, area):
    d = fits.open(targ_fn)[1].data
    # AR number of assigned fibers per target
    numobs_tot = d["NUMOBS_DONE"].sum(axis=1)
    # AR
    f = open(get_fn(args.outdir, "fastats-targ"), "w")
    f.write("# TRACER PRIORITY TARGET_DENS DONE_FRAC DONE_DENS MEAN_NFIBER\n")
    for tracer in tracers:
        ist = sel_tracer(d, tracer)
        # AR done?
        if tracer == "LYA":
            isdone = (ist) & (numobs_tot >= 4)
        else:
            isdone = (ist) & (numobs_tot >= 1)
        prios = ["ALL"]
        if tracer != "ALL":
            prios += np.unique(d["PRIORITY"][ist]).tolist()
        for prio in prios:
            if prio == "ALL":
                istp = ist.copy()
            else:
                istp = (ist) & (d["PRIORITY"] == prio)
            # AR done?
            if tracer == "LYA":
                istpd = (istp) & (numobs_tot >= 4)
            else:
                istpd = (istp) & (numobs_tot >= 1)
            f.write(
                "{}\t{}\t{:.0f}\t{:.2f}\t{:.0f}\t{:.1f}\n".format(
                    tracer,
                    prio,
                    istp.sum() / area,
                    istpd.sum() / istp.sum(),
                    istpd.sum() / area,
                    numobs_tot[istp].mean(),
                )
            )
    f.close()
    return True


# AR fastats-sky
def fastats_sky(passids, area):
    # AR
    f = open(get_fn(args.outdir, "fastats-sky"), "w")
    f.write("# PASS DONE_DENS EXTRA_DENS\n")
    ntot, ntot_extra = 0, 0
    for i in range(len(passids)):
        fn = os.path.join(
            args.outdir,
            "faruns",
            "farun-pass{}".format(passids[i]),
            "fba-sky-pass{}.fits".format(passids[i]),
        )
        d = fits.open(fn)[1].data
        # AR before cutting on "safe" box, assigning "extra" status to nfiber - (ntile x 10 x sky_per_petal fibers)
        ntile = len(np.unique(d["TILEID"]))
        nextra = len(d) - ntile * 10 * int(args.sky_per_petal)
        ii = np.random.choice(len(d), size=nextra, replace=False)
        is_extra = np.zeros(len(d), dtype=bool)
        is_extra[ii] = True
        # AR cutting out a safe "box" for analysis
        keep = sel_margin(
            d["TARGET_RA"], d["TARGET_DEC"], args.radec, args.radec_margin
        )
        f.write(
            "{}\t{:.0f}\t{:.0f}\n".format(
                passids[i], keep.sum() / area, ((keep) & (is_extra)).sum() / area
            )
        )
        ntot += keep.sum()
        ntot_extra += ((keep) & (is_extra)).sum()
    f.write("ALL\t{:.0f}\t{:.0f}".format(ntot / area, ntot_extra / area))
    f.close()
    return True


# AR find all pairs with search_radius (arcsec)
# AR copied from https://github.com/rongpu/desi-examples/blob/master/bright_star_contamination/match_coord.py
def search_around(ra1, dec1, ra2, dec2, search_radius=1.0, verbose=True):
    # protect the global variables from being changed by np.sort
    ra1, dec1, ra2, dec2 = list(map(np.copy, [ra1, dec1, ra2, dec2]))
    # Matching catalogs
    sky1 = SkyCoord(ra1 * units.degree, dec1 * units.degree, frame="icrs")
    sky2 = SkyCoord(ra2 * units.degree, dec2 * units.degree, frame="icrs")
    idx1, idx2, d2d, d3d = sky2.search_around_sky(
        sky1, seplimit=search_radius * units.arcsec
    )
    if verbose:
        print(("%d nearby objects" % len(idx1)))
    # convert distances to numpy array in arcsec
    d2d = np.array(d2d.to(units.arcsec))
    d_ra = (ra2[idx2] - ra1[idx1]) * 3600.0  # in arcsec
    d_dec = (dec2[idx2] - dec1[idx1]) * 3600.0  # in arcsec
    ##### Convert d_ra to actual arcsecs #####
    mask = d_ra > 180 * 3600
    d_ra[mask] = d_ra[mask] - 360.0 * 3600
    mask = d_ra < -180 * 3600
    d_ra[mask] = d_ra[mask] + 360.0 * 3600
    d_ra = d_ra * np.cos(dec1[idx1] / 180 * np.pi)
    ##########################################
    return idx1, idx2, d2d, d_ra, d_dec


# AR pair count diagnosis
# AR ! should be run on a region excluding the edges !
# AR based on Ashley https://github.com/desihub/LSS/blob/master/Sandbox/testassignments.ipynb
def fastats_pairs(tracers, targ_fn, d2dmax_degree):
    d = fits.open(targ_fn)[1].data
    ras, decs = d["RA"], d["DEC"]
    # AR number of assigned fibers per target
    numobs_tot = d["NUMOBS_DONE"].sum(axis=1)
    # AR count pairs
    f = open(get_fn(args.outdir, "fastats-pairs"), "w")
    f.write("# TRACER1 TRACER2 ASSGN2TGT RAND2TGT RATIO\n")
    for i1 in range(len(tracers) - 1):
        tracer1 = tracers[i1]
        ist1 = sel_tracer(d, tracer1)
        ist1assgn = (ist1) & (numobs_tot >= 1)
        for i2 in range(i1 + 1, len(tracers)):
            tracer2 = tracers[i2]
            ist2 = sel_tracer(d, tracer2)
            # AR excluding tracer1
            ist2 &= ~ist1
            ist2assgn = (ist2) & (numobs_tot >= 1)
            # AR TGT pairs
            _, _, d2d, _, _ = search_around(
                ras[ist1],
                decs[ist1],
                ras[ist2],
                decs[ist2],
                search_radius=d2dmax_degree * 3600,
                verbose=False,
            )
            np_tgt = len(d2d)
            # AR ASSGN pairs
            _, _, d2d, _, _ = search_around(
                ras[ist1assgn],
                decs[ist1assgn],
                ras[ist2assgn],
                decs[ist2assgn],
                search_radius=d2dmax_degree * 3600,
                verbose=False,
            )
            np_assgn = len(d2d)
            # AR fraction of pairs with both assigned
            frac_assgn = np_assgn / np_tgt
            # AR fraction of pairs if random
            frac_rand = (ist1assgn.sum() / ist1.sum()) * (ist2assgn.sum() / ist2.sum())
            f.write(
                "{}\t{}\t{:.2f}\t{:.2f}\t{:.2f}\n".format(
                    tracer1, tracer2, frac_assgn, frac_rand, frac_assgn / frac_rand,
                )
            )
    f.close()
    return True


def main():

    # AR create the tiles files
    if dotile:
        # AR then create tiles file
        _ = create_tiles(args.tilesfn, args.program, args.radec, args.outdir)

    # AR safe "box" area
    tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
    area_tile, area_safe = get_area(args.radec, tiles, args.radec_margin)
    print("area_tile = {} deg2, area_safe = {} deg2".format(area_tile, area_safe))

    # AR create the sky file
    if dosky:
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        if args.dtver in ["0.54.0.dev4695", "0.55.0.dev4725"]:
            hpdir = os.path.join(
                "/global/cscratch1/sd/adamyers/dr9", args.dtver, "skies"
            )
        else:
            hpdir = os.path.join(
                os.getenv("DESI_TARGET"), "catalogs", args.dr, args.dtver, "skies"
            )
        # AR we only store some columns
        columns = [
            "RA",
            "DEC",
            "TARGETID",
            "DESI_TARGET",
            "BGS_TARGET",
            "MWS_TARGET",
            "SUBPRIORITY",
            "OBSCONDITIONS",
            "PRIORITY_INIT",
            "NUMOBS_INIT",
        ]
        d = read_targets_in_tiles(hpdir, tiles, columns=columns, quick=True)
        fitsio.write(get_fn(args.outdir, "sky"), d, clobber=True)

    # AR create the targets file
    if dotarg:
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        # AR use randoms instead of targets?
        if args.randoms == "y":
            d, rand_dens = wrapper_read_randoms()
        else:
            d, = wrapper_read_targets()
        # AR mtl
        myd = Table(d)
        # AR assigns Lya
        myd["ISLYA"] = set_lya(d, args.lyafrac)
        # AR to store fa stats
        for key in ["NFIBER_AVAIL", "NTILE_AVAIL", "NUMOBS_DONE"]:
            myd[key] = np.zeros((len(d), args.npass), dtype=int)
        # AR flagging "safe" radec
        myd["ISRADEC_SAFE"] = sel_margin(
            d["RA"], d["DEC"], args.radec, args.radec_margin
        )
        # AR mtl
        mtl = make_mtl(myd.as_array(), args.program.upper())
        # AR tweak priority?
        if args.priority_mask is not None:
            mtl = tweak_priority(
                mtl, args.priority_mask, args.priority_frac, args.priority_new
            )
        mtl.write(get_fn(args.outdir, "targ"), overwrite=True)
        # AR propagating some settings into the PRIMARY header
        fd = fitsio.FITS(get_fn(args.outdir, "targ"), "rw")
        fd["MTL"].write_key("DTVER", args.dtver)
        fd["MTL"].write_key("SURVEY", args.survey)
        fd["MTL"].write_key("PROGRAM", args.program)
        fd["MTL"].write_key("RADEC", args.radec)
        fd["MTL"].write_key("MARGIN", args.radec_margin)
        fd["MTL"].write_key("AREATILE", area_tile)
        fd["MTL"].write_key("AREASAFE", area_safe)
        fd["MTL"].write_key("PRIOMASK", args.priority_mask)
        fd["MTL"].write_key("PRIOFRAC", args.priority_frac)
        fd["MTL"].write_key("PRIONEW", args.priority_new)
        fd["MTL"].write_key("TILESFN", args.tilesfn)
        fd["MTL"].write_key("RUNDATE", args.rundate)
        fd["MTL"].write_key("NSKYPET", args.sky_per_petal)
        fd["MTL"].write_key("NSTDPET", args.standards_per_petal)
        if args.randoms == "y":
            fd["MTL"].write_key("RANDDENS", rand_dens)
        fd.close()

    # AR run the fiber assignment + update the target file
    if dofa:
        # AR listing passids
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        passids = np.unique(tiles["PASS"])
        # AR sky_ra, sky_dec as global variable if args.numproc > 1
        if args.numproc > 1:
            global sky_ra, sky_dec
            d = fitsio.read(get_fn(args.outdir, "sky"), columns=["RA", "DEC"])
            sky_ra, sky_dec = d["RA"], d["DEC"]
        # AR looping on passids
        for ip in range(len(passids)):
            passid = passids[ip]
            # AR file/directory names
            if ip == 0:
                input_targ = get_fn(args.outdir, "targ")
                # AR targ_ra, targ_dec for as global variable if args.numproc > 1
                # AR same for all passids
                if args.numproc > 1:
                    global targ_ra, targ_dec
                    d = fitsio.read(input_targ, columns=["RA", "DEC"])
                    targ_ra, targ_dec = d["RA"], d["DEC"]
            else:
                input_targ = get_fn(args.outdir, "targ", passids[ip - 1])
            fadir = os.path.join(args.outdir, "faruns", "farun-pass{}".format(passid))
            output_targ = get_fn(args.outdir, "targ", passid)
            # AR clean fadir folder
            fns = glob(os.path.join(fadir, "fba-*.fits*"))
            if len(fns) > 0:
                for fn in fns:
                    os.remove(fn)
            # AR run fiber assignment
            if args.numproc == 1:
                opts = [
                    "--rundate",
                    args.rundate,
                    "--overwrite",
                    "--write_all_targets",
                    "--footprint",
                    get_fn(args.outdir, "tiles", passid=passid),
                    "--dir",
                    fadir,
                    "--sky",
                    get_fn(args.outdir, "sky"),
                    "--targets",
                    input_targ,
                    "--sky_per_petal",
                    args.sky_per_petal,
                    "--standards_per_petal",
                    args.standards_per_petal,
                ]
                print("Running raw fiber assignment (fba_run)...")
                ag = parse_assign(opts)
                run_assign_full(ag)
            else:
                # AR tileids for that passid
                tileids = tiles["TILEID"][tiles["PASS"] == passid]
                # AR tiles file for that passid
                foot_pass = get_fn(args.outdir, "tiles", passid=passid)
                # AR preparing files per tileid
                intargfn_fadir_footfn_skyfn_targfn = []
                for tileid in tileids:
                    # AR tileid filenames
                    footfn = foot_pass.replace(
                        ".fits", "-{:06d}.fits".format(int(tileid))
                    )
                    skyfn = footfn.replace("tiles-", "sky-")
                    targfn = footfn.replace("tiles-", "targ-")
                    h = fits.open(foot_pass)
                    h[1].data = h[1].data[h[1].data["TILEID"] == tileid]
                    h.writeto(footfn, overwrite=True)
                    # AR
                    intargfn_fadir_footfn_skyfn_targfn += [
                        ",".join([input_targ, fadir, footfn, skyfn, targfn])
                    ]
                pool = sharedmem.MapReduce(np=args.numproc)
                with pool:
                    _ = pool.map(
                        _do_run_assign_full, intargfn_fadir_footfn_skyfn_targfn
                    )

            # AR update the catalogs after having run fa + stats
            _ = update_after_farun(input_targ, fadir, passid, output_targ)
        # AR after last run, we provide a catalog cut on the safe region
        h = fits.open(get_fn(args.outdir, "targ", passid))
        h[1].data = h[1].data[h[1].data["ISRADEC_SAFE"]]
        h.writeto(
            get_fn(args.outdir, "targ", passid).replace(".fits", "-radec_safe.fits")
        )

    # AR analyze the runs
    if doresults:
        # AR passids
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        passids = np.unique(tiles["PASS"])

        # AR fastats-targ:
        # AR using the run for the last passid, cut on the "safe" region
        if args.randoms == "y":
            tracers = ["ELG"]
        else:
            tracers = ["ALL", "LYA", "QSO", "LRG", "ELG"]
        targ_fn = get_fn(args.outdir, "targ", passid=args.npass - 1).replace(
            ".fits", "-radec_safe.fits"
        )
        _ = fastats_targ(tracers, targ_fn, area_safe)

        # AR basic pair counting
        # AR cf. Ashley https://github.com/desihub/LSS/blob/master/Sandbox/testassignments.ipynb
        if args.randoms == "n":
            tracers = ["QSO", "LRG", "ELG"]
            d2dmax_degree = 0.01
            _ = fastats_pairs(tracers, targ_fn, d2dmax_degree)

        # AR fastats-sky:
        # AR using the whole region to get the numbers right
        _ = fastats_sky(passids, area_tile)


if __name__ == "__main__":

    # AR to speed up development/debugging
    dotile, dosky, dotarg, dofa, doresults = (
        False,
        False,
        False,
        False,
        False,
    )
    dotile = True
    dosky = True
    dotarg = True
    dofa = True
    doresults = True

    # AR reading arguments
    parser = ArgumentParser()
    parser.add_argument(
        "--outdir",
        help="root directory; all other paths are relative to that directory",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--program",
        help="dark or bright (default=dark)",
        type=str,
        default="dark",
        choices=["dark", "bright"],
    )
    parser.add_argument(
        "--randoms",
        help="use 2500/deg2 randoms instead of targets (default=n)",
        type=str,
        default="n",
        choices=["y", "n"],
    )                                                                                                                                                                  
    parser.add_argument(
        "--radec",
        help="ramin,ramax,decmin,decmax boundaries for tile centres (default=160,200,45,60)",
        type=str,
        default="160,200,45,60",
    )
    parser.add_argument(
        "--rundate",
        help="rundate for focalplane (default=2021-03-17T23:20:01)",
        type=str,
        default="2021-03-17T23:20:01",
    )
    parser.add_argument(
        "--dr",
        help="legacypipe dr (default=dr9)",
        type=str,
        default="dr9",
        choices=["dr8", "dr9"],
    )
    parser.add_argument(
        "--survey",
        help="main, sv1, sv2, sv3 (default=sv2)",
        type=str,
        default="sv2",
        choices=["sv1", "sv2", "sv3", "main"],
    )
    parser.add_argument(
        "--dtver",
        help="desitarget version (default=0.53.0)",
        type=str,
        default="0.53.0",
    )
    parser.add_argument(
        "--lyafrac",
        help="fraction of QSO targets which are Lya (default=0.2)",
        type=float,
        default=0.2,
    )
    parser.add_argument(
        "--tilesfn",
        help="tiles file full path (default: 4112packing-2021-03-29-formatted-dark15pass-bright4pass-backup4pass)",
        type=str,
        default="{}/survey/fiberassign/misc/tiles-4112packing-2021-03-29-formatted-dark15pass-bright4pass-backup4pass.fits".format(
            os.getenv("DESI_ROOT")
        ),
    )
    parser.add_argument(
        "--npass",
        help="number of tiling passes for the run (default: dark=7, bright=backup=4)",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--gray2dark",
        help="convert gray layer to dark layer in the tiles (default=y)",
        type=str,
        default="y",
        choices=["y", "n"],
    )
    parser.add_argument(
        "--rmvdarkbgs",
        help="remove BGS-only targets from dark observations? (default=y)",
        type=str,
        default="y",
        choices=["y", "n"],
    )
    parser.add_argument(
        "--standards_per_petal",
        help="required number of standards per petal (default=10)",
        type=str,
        default="10",
    )
    parser.add_argument(
        "--sky_per_petal",
        help="required number of sky targets per petal (default=40)",
        type=str,
        default="40",
    )
    parser.add_argument(
        "--priority_mask",
        help="comma-separated list of the desi_mask names to promote the priority of (e.g. ELG_HIP,LRG)",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--priority_frac",
        help="comma-separated list of the fraction of --priority_mask targets to promote (e.g. 0.25,0.15)",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--priority_new",
        help="comma-separated list of the priority values to promote the --priority_mask to (e.g. 3400,3400)",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--priority_lya",
        help="once observed, priority to be set for Lya (default=None, i.e. keep the same priority)",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--mtl_update",
        help="emulate mtl update of Z, ZWARN, ZTILEID, PRIORITY, TARGET_STATE after each pass? (default=y)",
        type=str,
        default="y",
        choices=["y", "n"],
    )
    parser.add_argument(
        "--radec_margin",
        help="margin in degrees to safely extract an inner box for analysis with non boundary effects; box will be cut by args.radec_margin in Dec. and args.radec_margin/cos(Dec.) in R.A. (default=2)",
        type=float,
        default=2,
    )
    parser.add_argument(
        "--nolog", help="do not print log file (default=n)", type=str, default="n",
    )
    parser.add_argument(
        "--numproc",
        help="number of concurrent processes to use (default=1)",
        type=int,
        default=1,
    )
    #
    args = parser.parse_args()

    # AR npass
    if args.npass is None:
        args.npass = 7 * (args.program == "dark") + 4 * (args.program != "dark")

    for kwargs in args._get_kwargs():
        print(kwargs)

    # AR safe
    if args.outdir[-1] != "/":
        args.outdir += "/"
    if (args.lyafrac < 0) | (args.lyafrac > 1):
        sys.exit(
            "args.lyafrac = {} => should be within 0 and 1; exiting".format(ags.lyafrac)
        )
    pm, pf, pn = args.priority_mask, args.priority_frac, args.priority_new
    if (pm is not None) | (pf is not None) | (pn is not None):
        if (pm is None) | (pf is None) | (pn is None):
            sys.exit(
                "args.priority_mask, args.priority_frac, args.priority_new should all be or not be None; exiting"
            )
        npm, npf, npn = len(pm.split(",")), len(pf.split(",")), len(pn.split(","))
        if (npm != npf) | (npm != npn) | (npf != npn):
            sys.exit(
                "inconsistent args.priority_mask, args.priority_frac, args.priority_new; exiting"
            )

    # AR outdir
    if not os.path.isdir(args.outdir):
        os.mkdir(args.outdir)

    # AR subdirs
    for subdir in ["inputs", "faruns", "outputs"]:
        if not os.path.isdir(os.path.join(args.outdir, subdir)):
            os.mkdir(os.path.join(args.outdir, subdir))

    # AR cleaning
    if dotile:
        for passid in [None] + np.arange(11, dtype=int).tolist():
            fn = get_fn(args.outdir, "tiles", passid=passid)
            if os.path.isfile(fn):
                os.remove(fn)
    if dosky:
        fn = get_fn(args.outdir, "sky")
        if os.path.isfile(fn):
            os.remove(fn)
    if dotarg:
        fn = get_fn(args.outdir, "targ")
        if os.path.isfile(fn):
            os.remove(fn)
    if dofa:
        fns = glob(os.path.join(args.outdir, "faruns", "farun-pass*", "*fits"))
        fns += [
            get_fn(args.outdir, "tiles", passid=passid)
            for passid in np.arange(args.npass, dtype=int)
        ]
        fns += [
            get_fn(args.outdir, "targ", passid=passid)
            for passid in np.arange(args.npass, dtype=int)
        ]
        fns += [
            get_fn(args.outdir, "targ", passid=args.npass - 1).replace(
                ".fits", "-radec_safe.fits"
            )
        ]
        for fn in fns:
            if os.path.isfile(fn):
                os.remove(fn)

    # AR saving settings
    fn = open(get_fn(args.outdir, "settings"), "w")
    for kwargs in args._get_kwargs():
        fn.write("{} = {}\n".format(kwargs[0], kwargs[1]))
    fn.write("\n")
    fn.write(
        "python {} {}\n".format(
            sys.argv[0],
            " ".join(
                [
                    "--" + kwargs[0] + " " + str(kwargs[1])
                    for kwargs in args._get_kwargs()
                    if kwargs[1] is not None
                ]
            ),
        )
    )
    fn.write("\n")
    fn.close()

    # AR log file
    if args.nolog == "n":
        logfn = get_fn(args.outdir, "log")
    else:
        logfn = None

    # AR reproducible random seed
    np.random.seed(12345)

    # AR mask + key used to select targets
    if args.survey == "main":
        from desitarget.targetmask import desi_mask

        dtkey = "DESI_TARGET"
    if args.survey == "sv1":
        from desitarget.sv1.sv1_targetmask import desi_mask

        dtkey = "SV1_DESI_TARGET"
    if args.survey == "sv2":
        from desitarget.sv2.sv2_targetmask import desi_mask

        dtkey = "SV2_DESI_TARGET"
    if args.survey == "sv3":
        from desitarget.sv3.sv3_targetmask import desi_mask

        dtkey = "SV3_DESI_TARGET"

    # AR: log filename
    if args.nolog == "n":
        if os.path.isfile(logfn):
            os.remove(logfn)
        with stdouterr_redirected(to=logfn):
            main()
    else:
        main()
