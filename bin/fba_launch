#!/usr/bin/env python

import os
import sys
import subprocess
import numpy as np
from glob import glob
from astropy.io import fits
from astropy.table import Table
import fitsio
import desitarget
from desitarget.io import read_targets_in_tiles, write_targets, write_skies
from desitarget.mtl import inflate_ledger
from desitarget.targetmask import desi_mask, obsconditions
from desitarget.targets import set_obsconditions
import desimodel
from desimodel.footprint import is_point_in_desi
import fiberassign
from fiberassign.fba_launch_io import assert_env_vars, assert_svn_tileid, assert_arg_dates, print_config_infos, get_desitarget_paths, custom_read_targets_in_tiles, mv_write_targets_out, force_finite_pm, force_nonzero_refepoch, update_nowradec, create_tile, create_sky, create_gfa, create_mtl, create_too, launch_onetile_fa, update_fiberassign_header
from fiberassign.scripts.assign import parse_assign, run_assign_full
from fiberassign.assign import merge_results, minimal_target_columns
from fiberassign.utils import Logger
from time import time
from datetime import datetime, timezone
import matplotlib.pyplot as plt
from matplotlib import gridspec
import matplotlib
from astropy import units
from astropy.coordinates import SkyCoord, Distance
from astropy.time import Time
import matplotlib.image as mpimg
import tempfile
import shutil
from desiutil.redirect import stdouterr_redirected
from argparse import ArgumentParser

# AR goal effective time
# AR https://desi.lbl.gov/svn/data/surveyops/trunk/ops/config-sv2.yaml
# AR https://desi.lbl.gov/svn/data/surveyops/trunk/ops/config-sv3.yaml as of Apr. 5th
goaltimes_all = {
    "sv2": {"DARK": 1000.0, "BRIGHT": 150.0, "BACKUP": 30.0},
    "sv3": {"DARK": 1200.0, "BRIGHT": 220.0, "BACKUP": 30.0},
}

# AR surface brightness profile to be used for computing time -> efftime relation
sbprofs_all = {
    "sv2": {"DARK": "ELG", "BRIGHT": "BGS", "BACKUP": "PSF"},
    "sv3": {"DARK": "ELG", "BRIGHT": "BGS", "BACKUP": "PSF"},
}

# AR default REF_EPOCH for PMRA=PMDEC=REF_EPOCH=0 objects
ref_epochs = {
    "gaiadr2" : 2015.5
}


# AR for qa plot
tile_radius_deg = 1.628


# AR get matching index for two np arrays, those should be arrays with unique values, like id
# AR https://stackoverflow.com/questions/32653441/find-indices-of-common-values-in-two-arrays
# AR we get: A[maskA] = B[maskB]
def unq_searchsorted(A, B):
    # AR sorting A,B
    tmpA = np.sort(A)
    tmpB = np.sort(B)
    # AR create mask equivalent to np.in1d(A,B) and np.in1d(B,A) for unique elements
    maskA = (
        np.searchsorted(tmpB, tmpA, "right") - np.searchsorted(tmpB, tmpA, "left")
    ) == 1
    maskB = (
        np.searchsorted(tmpA, tmpB, "right") - np.searchsorted(tmpA, tmpB, "left")
    ) == 1
    # AR to get back to original indexes
    return np.argsort(A)[maskA], np.argsort(B)[maskB]


def mycmap(name, n, cmin, cmax):
    cmaporig = matplotlib.cm.get_cmap(name)
    mycol = cmaporig(np.linspace(cmin, cmax, n))
    cmap = matplotlib.colors.ListedColormap(mycol)
    cmap.set_under(mycol[0])
    cmap.set_over(mycol[-1])
    return cmap


# AR dra,ddec position in tile (in degrees)
def get_tpos(tsky, ra, dec):
    sky = SkyCoord(ra=ra * units.deg, dec=dec * units.deg, frame="icrs")
    spho = tsky.spherical_offsets_to(sky)
    return spho[0].value, spho[1].value


# AR convert (dra,ddec) to (x,y) in cutout img pixels
# AR not sure at <1 pixel...
def deg2pix(x, y, size, rdlim):
    return (
        size - (size / 2.0 + x / rdlim * size / 2.0),
        size / 2.0 + y / rdlim * size / 2.0,
    )


# AR plot cutout + data
def plot_cutout(
    ax,
    img,
    rdlim,
    x,
    y,
    pet=False,
    c="w",
    alpha=None,
    txts=None,
    xtxts=None,
    ytxts=None,
    vmin=None,
    vmax=None,
    cmap=mycmap("jet_r", 10, 0, 1),
):
    # AR txts, xtxts, ytxts : lists
    # AR setting transparency as a function of density /deg2
    if (x is not None) & (alpha is None):
        tmpdens = np.array([0, 100, 500, 1000, 5000, 7500, 1e10],)
        tmpalph = np.array([1, 0.8, 0.5, 0.2, 0.1, 0.05, 0.025])
        alpha = tmpalph[
            np.where(tmpdens > len(x) / (np.pi * tile_radius_deg ** 2))[0][0]
        ]
    size = img.shape[0]
    ax.imshow(img, origin="upper", zorder=0, extent=[0, size, 0, size], aspect="equal")
    ax.set_aspect("equal")
    ax.set_xlim(-0.5, size + 0.5)
    ax.set_ylim(-0.5, size + 0.5)
    # AR data points
    if x is not None:
        # AR rescaling degrees to img pixels ; not sure at <1 pixel...
        xx, yy = deg2pix(x, y, size, rdlim)
        yy = size / 2.0 + y / rdlim * size / 2.0
        if isinstance(c, str):
            ax.scatter(xx, yy, c=c, s=1, alpha=alpha)
        else:
            ax.scatter(xx, yy, c=c, s=1, alpha=alpha, vmin=vmin, vmax=vmax, cmap=cm)
    # AR per petal infos
    if pet:
        for ang, p in zip(
            np.linspace(2 * np.pi, 0, 11), [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]
        ):
            xx, yy = deg2pix(
                np.array([0, tile_radius_deg * np.cos(ang)]),
                np.array([0, tile_radius_deg * np.sin(ang)]),
                size,
                rdlim,
            )
            ax.plot(
                xx, yy, c="r", lw=0.25, alpha=1.0, zorder=1,
            )
            anglab = ang + 0.1 * np.pi
            xx, yy = deg2pix(
                1.1 * tile_radius_deg * np.cos(anglab),
                1.1 * tile_radius_deg * np.sin(anglab),
                size,
                rdlim,
            )
            ax.text(
                xx, yy, "{:.0f}".format(p), color="r", va="center", ha="center",
            )

    ax.axis("off")
    if txts is not None:
        for txt, xtxt, ytxt in zip(txts, xtxts, ytxts):
            ax.text(
                xtxt,
                ytxt,
                txt,
                color="y",
                fontweight="bold",
                fontsize=10,
                ha="center",
                va="top",
                transform=ax.transAxes,
            )
    return


def plot_hist(ax, x, xp, msk):
    # x : x-quantity for the assigned sample
    # xp: x-quantity for the parent sample
    #
    selp = np.isfinite(xp)
    sel = np.isfinite(x)
    bins = np.linspace(xp[selp].min(), xp[selp].max(), 26)
    #
    cps, _, _ = ax.hist(
        xp[selp],
        bins=bins,
        histtype="step",
        alpha=0.3,
        lw=3,
        color="k",
        density=False,
        label="{} parent ({})".format(msk, len(xp)),
    )
    cs, _, _, = ax.hist(
        x[sel],
        bins=bins,
        histtype="step",
        alpha=1.0,
        lw=1.0,
        color="k",
        density=False,
        label="{} assigned ({})".format(msk, len(x)),
    )
    ax.set_ylabel("counts")
    ax.grid(True)
    # ax.legend(loc=2)
    axr = ax.twinx()
    axr.plot(
        0.5 * (bins[1:] + bins[:-1]),
        np.array(cs) / np.array(cps).astype(float),
        color="r",
        lw=0.5,
    )
    axr.yaxis.label.set_color("r")
    axr.tick_params(axis="y", colors="r")
    axr.set_ylabel("ratio", labelpad=0)
    axr.set_ylim(0, 1)
    txts = [msk, "assigned/parent = {}/{}".format(len(x), len(xp))]
    xtxts = [0.5, 0.5]
    ytxts = [0.98, 0.90]
    for txt, xtxt, ytxt in zip(txts, xtxts, ytxts):
        ax.text(
            xtxt,
            ytxt,
            txt,
            color="k",
            fontweight="bold",
            fontsize=10,
            ha="center",
            va="top",
            transform=ax.transAxes,
        )
    return


def main():
    #
    start = time()
    log.info("{:.1f}s\tstart\tTIMESTAMP={}".format(time() - start, Time.now().isot))

    log.info("")
    log.info("")
    log.info("{:.1f}s\tsettings\tTIMESTAMP={}".format(time() - start, Time.now().isot))
    # AR printing settings
    tmpstr = " , ".join(
        [kwargs[0] + "=" + str(kwargs[1]) for kwargs in args._get_kwargs()]
    )
    log.info("{:.1f}s\tsettings\targs: {}".format(time() - start, tmpstr))

    # AR safe: DESI environment variables defined?
    assert_env_vars(log=log, step="settings", start=start)

    # AR safe: TILEID already existing in SVN?
    assert_svn_tileid(args.tileid, log=log, step="settings", start=start)

    # AR safe: argument dates correctly formatted?
    assert_arg_dates(args, log=log, step="settings", start=start)

    # AR print general configuration informations
    print_config_infos(log=log, step="settings", start=start)

    # AR (temporary) output files
    for key in list(myouts.keys()):
        log.info(
            "{:.1f}s\tsettings\toutput file for {}: {}".format(
                time() - start, key, myouts[key]
            )
        )
    for key in list(mytmpouts.keys()):
        log.info(
            "{:.1f}s\tsettings\ttemporary output file for {}: {}".format(
                time() - start, key, mytmpouts[key]
            )
        )

    # AR obscon : for the tile observing conditions, permissive value
    obscon = "DARK|GRAY|BRIGHT|BACKUP"
    log.info("{:.1f}s\tsettings\ttile obscon={}".format(time() - start, obscon))

    # AR desitarget folders/files
    # AR folder architecture is now the same at NERSC/KPNO (https://github.com/desihub/fiberassign/issues/302)
    # AR DESI_ROOT : NERSC: '/global/cfs/cdirs/desi' ; KPNO: '/data/datasystems'
    mydirs = get_desitarget_paths(
        args.dtver,
        args.survey,
        args.program,
        dr=args.dr,
        gaiadr=args.gaiadr,
        log=log,
        step="settings",
        start=start,)

    # AR tiles
    if dotile:
        create_tile(
            args.tileid,
            args.tilera,
            args.tiledec,
            mytmpouts["tiles"],
            args.survey,
            obscon=obscon,
            log=log,
            step="dotile",
            start=start,
        )

    # AR sky
    if dosky:
        create_sky(
            mytmpouts["tiles"],
            mydirs["sky"],
            mytmpouts["sky"],
            suppskydir=mydirs["skysupp"],
            tmpoutdir=tmpoutdir,
            log=log,
            step="dosky",
            start=start,
        )

    # AR gfa
    if dogfa:
        create_gfa(
            mytmpouts["tiles"],
            mydirs["gfa"],
            args.survey,
            args.gaiadr.replace("gaia", ""),
            args.pmcorr,
            mytmpouts["gfa"],
            tmpoutdir=tmpoutdir,
            pmtime_utc_str=args.pmtime_utc_str,
            log=log,
            step="dogfa",
            start=start,
        )

    # AR mtl
    if domtl:
        create_mtl(
            mytmpouts["tiles"],
            mydirs["mtl"],
            args.mtltime,
            mydirs["targ"],
            args.survey,
            args.gaiadr.replace("gaia", ""),
            args.pmcorr,
            mytmpouts["targ"],
            tmpoutdir=tmpoutdir,
            pmtime_utc_str=args.pmtime_utc_str,
            log=log,
            step="domtl",
            start=start,
        )

    # AR secondary targets
    # AR if not backup
    if (doscnd) & ("scnd" in list(mydirs.keys())):
        create_mtl(
            mytmpouts["tiles"],
            mydirs["scndmtl"],
            args.mtltime,
            mydirs["scnd"],
            args.survey,
            args.gaiadr.replace("gaia", ""),
            args.pmcorr,
            mytmpouts["scnd"],
            tmpoutdir=tmpoutdir,
            pmtime_utc_str=args.pmtime_utc_str,
            log=log,
            step="doscnd",
            start=start,
        )
    else:
        log.info(
            "{:.1f}s\tdoscnd\tno secondary here".format(
                time() - start
            )
        )

    # AR ToO targets
    if dotoo:
        create_too(
            mytmpouts["tiles"],
            mydirs["too"],
            mjd_now - 1,
            mjd_now + 30,
            args.survey,
            args.gaiadr.replace("gaia", ""),
            args.pmcorr,
            mytmpouts["too"],
            tmpoutdir=tmpoutdir,
            pmtime_utc_str=args.pmtime_utc_str,
            log=log,
            step="dotoo",
            start=start,
        )

    # AR fiberassign
    if dofa:
        # AR prepare targfns
        targfns = [mytmpouts["targ"]]
        if (doscnd) & (os.path.isfile(mytmpouts["scnd"])):
            targfns.append(mytmpouts["scnd"])
        if (dotoo) & (os.path.isfile(mytmpouts["too"])):
            targfns.append(mytmpouts["too"])

        # AR launch_onetile_fa
        launch_onetile_fa(
            args,
            mytmpouts["tiles"],
            targfns,
            mytmpouts["fba"],
            mytmpouts["fiberassign"],
            skyfn=mytmpouts["sky"],
            gfafn=mytmpouts["gfa"],
            log=log,
            step="dofa",
            start=start,
        )

        # AR propagating some settings into the PRIMARY header
        faflavor = "{}{}".format(args.survey, args.program.lower())
        ebv = fitsio.read(mytmpouts["targ"], columns=["EBV"])["EBV"]
        fascript = sys.argv[0]
        update_fiberassign_header(
            mytmpouts["fiberassign"],
            args,
            mydirs,
            faflavor,
            ebv,
            obscon,
            fascript,
            log=log,
            step="dofa",
            start=start,
        )

    # AR gzip all fiberassign files
    if dozip:
        log.info("")
        log.info("")
        log.info("{:.1f}s\tdozip\tTIMESTAMP={}".format(time() - start, Time.now().isot))
        if os.path.isfile("{}.gz".format(mytmpouts["fiberassign"])):
            os.remove("{}.gz".format(mytmpouts["fiberassign"]))
            log.info(
                "{:.1f}s\tdozip\tdeleting existing {}.gz".format(
                    time() - start, mytmpouts["fiberassign"]
                )
            )
        os.system("gzip {}".format(mytmpouts["fiberassign"]))
        log.info(
            "{:.1f}s\tdozip\tgzipping {}".format(
                time() - start, mytmpouts["fiberassign"]
            )
        )
        # AR updating the path
        mytmpouts["fiberassign"] += ".gz"
        myouts["fiberassign"] += ".gz"

    # AR QA plots
    if doplot:

        log.info("")
        log.info("")
        log.info(
            "{:.1f}s\tdoplot\tTIMESTAMP={}".format(time() - start, Time.now().isot)
        )
        # AR masks
        # AR close to desitarget.targets.main_cmx_or_sv,
        # AR but using a dictionary, more adapted to this code
        if args.survey == "sv2":
            from desitarget.sv2 import sv2_targetmask as targetmask
            from fiberassign.targets import default_sv2_stdmask as default_stdmask
        if args.survey == "sv3":
            from desitarget.sv3 import sv3_targetmask as targetmask
            from fiberassign.targets import default_sv3_stdmask as default_stdmask
        yaml_masks = {
            "DESI_TARGET": targetmask.desi_mask,
            "BGS_TARGET": targetmask.bgs_mask,
            "MWS_TARGET": targetmask.mws_mask,
            "SCND_TARGET": targetmask.scnd_mask,
        }
        # AR WD masks
        wd_mskkeys, wd_msks = [], []
        for mskkey in ["DESI_TARGET", "MWS_TARGET"]:
            wd_mskkeys += [mskkey for key in yaml_masks[mskkey].names() if "_WD" in key]
            wd_msks += [key for key in yaml_masks[mskkey].names() if "_WD" in key]
        log.info("{:.1f}s\tdoplot\twd_mskkeys = {}".format(time() - start, wd_mskkeys))
        log.info("{:.1f}s\tdoplot\twd_msks = {}".format(time() - start, wd_msks))
        # AR STD masks
        std_mskkeys, std_msks = [], []
        for mskkey in ["DESI_TARGET", "MWS_TARGET"]:
            std_mskkeys += [
                mskkey for key in yaml_masks[mskkey].names() if "STD" in key
            ]
            std_msks += [key for key in yaml_masks[mskkey].names() if "STD" in key]
        log.info(
            "{:.1f}s\tdoplot\tstd_mskkeys = {}".format(time() - start, std_mskkeys)
        )
        log.info("{:.1f}s\tdoplot\tstd_msks = {}".format(time() - start, std_msks))

        # AR hard-setting the plotted tracers
        # AR TBD: handle secondaries
        if args.program == "DARK":
            trmskkeys = ["DESI_TARGET", "DESI_TARGET", "DESI_TARGET"]
            trmsks = ["LRG", "ELG", "QSO"]
        if args.program == "BRIGHT":
            trmskkeys = ["BGS_TARGET", "BGS_TARGET"]
            trmsks = ["BGS_BRIGHT", "BGS_FAINT"]
            trmskkeys += ["MWS_TARGET", "MWS_TARGET"]
            trmsks += ["MWS_BROAD", "MWS_NEARBY"]
        if args.program == "BACKUP":
            trmskkeys = ["MWS_TARGET", "MWS_TARGET", "MWS_TARGET"]
            trmsks = ["BACKUP_BRIGHT", "BACKUP_FAINT", "BACKUP_VERY_FAINT"]

        # AR various settings
        tile_radius_deg = 1.628
        cm = mycmap("coolwarm", 10, 0, 1)
        rdlim = 2  # AR will use dra_lim = (rdlim,-rdlim) , ddec_lim = (-rdlim,rdlim)
        # AR tile ra,dec
        tsky = SkyCoord(
            ra=args.tilera * units.deg, dec=args.tiledec * units.deg, frame="icrs"
        )
        tarea = np.pi * tile_radius_deg ** 2  # AR approx. tile area in degrees

        # AR control plots
        pet = {}
        dra, ddec = {}, {}
        parent = {}
        assign = {}
        nassign = {}
        # AR keys we use (plus few for assign)
        keys = [
            "TARGETID",
            "FLUX_G",
            "FLUX_R",
            "FIBERTOTFLUX_R",
            "FLUX_Z",
            "FLUX_W1",
            "FLUX_W2",
            "EBV",
            "GAIA_PHOT_G_MEAN_MAG",
            "RA",
            "DEC",
            "DESI_TARGET",
            "BGS_TARGET",
            "MWS_TARGET",
            "SCND_TARGET",
        ]
        # AR parent
        fns = [mytmpouts["targ"]]
        if os.path.isfile(mytmpouts["scnd"]):
            fns += [mytmpouts["scnd"]]
        for key in keys:
            parent[key] = []
        for fn in fns:
            d = fits.open(fn)[1].data
            for key in keys:
                if (
                    key in ["DESI_TARGET", "BGS_TARGET", "MWS_TARGET", "SCND_TARGET",]
                ) & (args.survey[:2] == "sv"):
                    parent[key] += d["{}_{}".format(args.survey.upper(), key)].tolist()
                # AR flux, ebv for secondary
                elif key not in d.dtype.names:
                    parent[key] += [0. for x in d["RA"]]
                else:
                    parent[key] += d[key].tolist()
        for key in keys:
            parent[key] = np.array(parent[key])
        dra["parent"], ddec["parent"] = get_tpos(tsky, parent["RA"], parent["DEC"])

        # AR fiberassign
        d = fits.open(mytmpouts["fiberassign"])[1].data
        # AR
        for key in ["SKY", "BAD", "TGT"]:
            nassign[key] = (d["OBJTYPE"] == key).sum()
        # AR SKY
        keep = d["OBJTYPE"] == "SKY"
        dra["sky"], ddec["sky"] = get_tpos(
            tsky, d["TARGET_RA"][keep], d["TARGET_DEC"][keep]
        )
        pet["sky"] = d["PETAL_LOC"][keep]
        # AR BAD
        keep = d["OBJTYPE"] == "BAD"
        dra["bad"], ddec["bad"] = get_tpos(
            tsky, d["TARGET_RA"][keep], d["TARGET_DEC"][keep]
        )
        pet["bad"] = d["PETAL_LOC"][keep]
        # AR TGT
        # AR arrays twinning the parent ordering, with nans/zeros
        # AR e.g. SV2_DESI_TARGET -> DESI_TARGET
        d = d[d["OBJTYPE"] == "TGT"]
        iip, ii = unq_searchsorted(parent["TARGETID"], d["TARGETID"])
        keys = [key for key in keys if key != "RA" and key != "DEC"]
        keys += [
            "TARGET_RA",
            "TARGET_DEC",
            "PETAL_LOC",
        ]
        for key in keys:
            if key in [
                "TARGETID",
                "DESI_TARGET",
                "BGS_TARGET",
                "MWS_TARGET",
                "SCND_TARGET",
            ]:
                assign[key] = np.zeros(len(parent["TARGETID"]), dtype=int)
                if (key != "TARGETID") & (args.survey[:2] == "sv"):
                    assign[key][iip] = d["{}_{}".format(args.survey.upper(), key)][ii]
                else:
                    assign[key][iip] = d[key][ii]
            else:
                assign[key] = np.nan + np.zeros(len(parent["TARGETID"]))
                assign[key][iip] = d[key][ii]
        dra["assign"], ddec["assign"] = get_tpos(
            tsky, assign["TARGET_RA"], assign["TARGET_DEC"]
        )
        # AR WD
        keep = np.zeros(len(assign["TARGET_RA"]), dtype=bool)
        for mskkey, msk in zip(wd_mskkeys, wd_msks):
            keep |= (assign[mskkey] & yaml_masks[mskkey][msk]) > 0
        dra["wd"], ddec["wd"] = get_tpos(
            tsky, assign["TARGET_RA"][keep], assign["TARGET_DEC"][keep]
        )
        pet["wd"] = assign["PETAL_LOC"][keep]
        nassign["WD"] = keep.sum()
        # AR STD
        keep = np.zeros(len(assign["TARGET_RA"]), dtype=bool)
        for mskkey, msk in zip(std_mskkeys, std_msks):
            keep |= (assign[mskkey] & yaml_masks[mskkey][msk]) > 0
        dra["std"], ddec["std"] = get_tpos(
            tsky, assign["TARGET_RA"][keep], assign["TARGET_DEC"][keep]
        )
        pet["std"] = assign["PETAL_LOC"][keep]
        nassign["STD"] = keep.sum()

        # AR stats : assigned / parent
        yaml_masks = {
            "DESI_TARGET": targetmask.desi_mask,
            "BGS_TARGET": targetmask.bgs_mask,
            "MWS_TARGET": targetmask.mws_mask,
            "SCND_TARGET": targetmask.scnd_mask,
        }
        log.info("======= ASSIGNMENT STATISTICS : START =======")
        log.info("# MASKKEY\tMASK\tPARENT\tASSIGN\tFRACTION")
        for mskkey in list(yaml_masks.keys()):
            if args.survey[:2] == "sv":
                mskkey_orig = "{}_{}".format(args.survey.upper(), mskkey)
            else:
                mskkey_orig = mskkey
            for msk in yaml_masks[mskkey].names():
                nparent = ((parent[mskkey] & yaml_masks[mskkey][msk]) > 0).sum()
                nassign = ((assign[mskkey] & yaml_masks[mskkey][msk]) > 0).sum()
                if nparent == 0:
                    frac = 0.0
                else:
                    frac = nassign / nparent
                log.info(
                    "{}\t{}\t{}\t{}\t{:.2f}".format(
                        mskkey_orig, msk, nparent, nassign, frac
                    )
                )
        log.info("======= ASSIGNMENT STATISTICS : END =======")

        # AR start plotting
        fig = plt.figure(figsize=(30, 3 * (1 + len(trmsks))))
        gs = gridspec.GridSpec(1 + len(trmsks), 7, wspace=0.5, hspace=0.3)

        # AR overall infos
        ax = plt.subplot(gs[0, 0])
        ax.axis("off")
        # AR infos : general
        x, y, dy, fs = 0.05, 0.95, -0.1, 10
        for t in [
            "flavor={}".format(fits.getheader(mytmpouts["fiberassign"])["FAFLAVOR"]),
            "TILEID={:06d}".format(args.tileid),
            "RA,DEC={:.3f},{:.3f}".format(args.tilera, args.tiledec),
            "obscon={}".format(obscon),
            "rundate={}".format(args.rundate),
            "",
        ]:
            ax.text(x, y, t.expandtabs(), fontsize=fs, transform=ax.transAxes)
            y += dy
        # AR infos: wd/std + tracers
        xs = [0.05, 0.65, 0.95, 1.20]
        has = ["left", "right", "right", "right"]
        tracers = []
        for mskkey, msk in zip(wd_mskkeys + std_mskkeys, wd_msks + std_msks):
            n = ((assign[mskkey] & yaml_masks[mskkey][msk]) > 0).sum()
            tracers += [[msk, "{}".format(n), "", ""]]
        tracers += [["", "", "", ""], ["MASK", "ASSGN", "PARENT", "FAFRAC"]]
        for msk, mskkey in zip(trmsks, trmskkeys):
            nparent = ((parent[mskkey] & yaml_masks[mskkey][msk]) > 0).sum()
            n = ((assign[mskkey] & yaml_masks[mskkey][msk]) > 0).sum()
            tracers += [
                [
                    msk,
                    "{}".format(n),
                    "{}".format(nparent),
                    "{:.2f}".format(n / nparent),
                ]
            ]
        tracers += [["", "", "", ""]]
        for tracer in tracers:
            for i in range(4):
                ax.text(
                    xs[i],
                    y,
                    tracer[i].expandtabs(),
                    fontsize=fs,
                    ha=has[i],
                    transform=ax.transAxes,
                )
            y += dy
        # AR infos: brightest target and assigned object
        # AR infos: taking a default 16, in case new programs are added
        magthresh = 16.
        if args.program == "DARK":
            magthres = 16.
        if args.program == "BRIGHT":
            magthresh = 15.
        if args.program == "BACKUP":
            magthresh = 15.
        for sample, d in zip(["parent", "assgn"], [parent, assign]):
            ax.text(0.05, y, "Min. {} mag ".format(sample), fontsize=fs, transform=ax.transAxes)
            y += dy
            for mag, lab in zip(
                [d["GAIA_PHOT_G_MEAN_MAG"], 22.5 - 2.5 * np.log10(d["FIBERTOTFLUX_R"])],
                ["GAIA_PHOT_G_MEAN_MAG)", "min(LS-R-FIBTOTMAG)"],
            ):
                magmin, color = "-", "k"
                keep = (np.isfinite(mag)) & (mag > 0)
                if keep.sum() > 0:
                    magmin = mag[keep].min()
                    if magmin < magthresh:
                        magmin, color = "{:.1f}".format(magmin), "r"
                    else:
                        magmin, color = "{:.1f}".format(magmin), "k"
                ax.text(
                    0.05,
                    y,
                    "{} = {}".format(lab, magmin),
                    fontsize=fs,
                    color=color,
                    transform=ax.transAxes,
                )
                y += dy
            y += dy

        # AR stats per petal
        ax = plt.subplot(gs[0, 1])
        ax.axis("off")
        # x0, x1, x2, x3, x4, x5 = 0.05, 0.25, 0.45, 0.65, 0.85, 1.05
        xs = [0.05, 0.25, 0.45, 0.65, 0.85, 1.05]
        ts = ["PETAL", "NSKY", "NBAD", "NWD", "NSTD", "NTGT"]
        y, dy = 0.95, -0.1
        fs = 10
        for i in range(6):
            ax.text(xs[i], y, ts[i], fontsize=fs, ha="center", transform=ax.transAxes)
        y += dy
        for p in range(10):
            if (pet["std"] == p).sum() == 0:
                color = "r"
            else:
                color = "k"
            ts = [
                "{:.0f}".format(p),
                "{:.0f}".format((pet["sky"] == p).sum()),
                "{:.0f}".format((pet["bad"] == p).sum()),
                "{:.0f}".format((pet["wd"] == p).sum()),
                "{:.0f}".format((pet["std"] == p).sum()),
                "{:.0f}".format((assign["PETAL_LOC"] == p).sum()),
            ]
            for i in range(6):
                ax.text(
                    xs[i],
                    y,
                    ts[i],
                    color=color,
                    fontsize=fs,
                    ha="center",
                    transform=ax.transAxes,
                )
            y += dy
        # AR stats for all petals
        ts = [
            "ALL",
            "{:.0f}".format(len(pet["sky"])),
            "{:.0f}".format(len(pet["bad"])),
            "{:.0f}".format(len(pet["wd"])),
            "{:.0f}".format(len(pet["std"])),
            "{:.0f}".format(np.isfinite(assign["PETAL_LOC"]).sum()),
        ]
        for i in range(6):
            ax.text(
                xs[i],
                y,
                ts[i],
                color=color,
                fontsize=fs,
                ha="center",
                transform=ax.transAxes,
            )

        # AR cutout
        pixscale = 10
        size = int(2 * rdlim * 3600.0 / pixscale)
        layer = "ls-{}".format(args.dr)
        tmpstr = 'wget -q -O {}tmp-{}.jpeg "http://legacysurvey.org/viewer-dev/jpeg-cutout/?layer={}&ra={:.5f}&dec={:.5f}&pixscale={:.0f}&size={:.0f}"'.format(
            tmpoutdir, args.tileid, layer, args.tilera, args.tiledec, pixscale, size
        )
        #  print(tmpstr)
        os.system(tmpstr)
        try:
            img = mpimg.imread("{}tmp-{}.jpeg".format(tmpoutdir, args.tileid))
            os.remove("{}tmp-{}.jpeg".format(tmpoutdir, args.tileid))
        except:
            img = np.zeros((size, size, 3))
        # img = np.zeros((size, size, 3))

        # AR SKY, BAD, WD, STD, TGT
        for iy, x, y, txt, alpha in zip(
            [2, 3, 4, 5, 6],
            [dra["sky"], dra["bad"], dra["wd"], dra["std"], dra["assign"]],
            [ddec["sky"], ddec["bad"], ddec["wd"], ddec["std"], ddec["assign"]],
            ["SKY", "BAD", "WD", "STD", "TGT"],
            [0.25, 1.0, 1.0, 1.0, 0.025],
        ):
            ax = fig.add_subplot(gs[0, iy])
            plot_cutout(
                ax,
                img,
                rdlim,
                x,
                y,
                pet=True,
                alpha=alpha,
                txts=[txt],
                xtxts=[0.2],
                ytxts=[0.98],
            )

        # AR looping on tracers
        # AR https://www.legacysurvey.org/dr9/catalogs/#galactic-extinction-coefficients
        exts = {"G": 3.214, "R": 2.165, "Z": 1.211, "W1": 0.184, "W2": 0.113}
        ix = 1
        for msk, mskkey in zip(trmsks, trmskkeys):
            # AR selecting the relevant tracers
            if mskkey in list(parent.keys()):
                mskpsel = (parent[mskkey] & yaml_masks[mskkey][msk]) > 0
            else:
                mskpsel = np.zeros(len(parent["TARGETID"]), dtype=bool)
            # AR if no parent target, just skip
            if mskpsel.sum() == 0:
                continue
            msksel = (assign[mskkey] & yaml_masks[mskkey][msk]) > 0
            fafrac = msksel.sum() / float(mskpsel.sum())
            # famin = np.clip(fafrac-0.2,0,1)
            # famax = np.clip(fafrac+0.2,0,1)
            famin, famax = 0, 1
            # AR mag hist
            band, famin, famax = "G", 0.0, 0.5
            if "MWS" in msk:
                band, famin, famax = "R", 0.0, 0.2
            if "BGS" in msk:
                band, famin, famax = "R", 0.25, 0.45
            if "LRG" in msk:
                band, famin, famax = "Z", 0.3, 0.5
            if "ELG" in msk:
                band, famin, famax = "G", 0.05, 0.15
            if "QSO" in msk:
                band, famin, famax = "R", 0.6, 0.8
            #
            ax = plt.subplot(gs[ix, 1])
            dohist = 0
            # AR if ls-dr9 flux is here, we plot that
            if ((parent["FLUX_" + band] > 0) & (mskpsel)).sum() > 0:
                dohist = 1
                xp = (
                    22.5
                    - 2.5 * np.log10(parent["FLUX_" + band][mskpsel])
                    - exts[band] * parent["EBV"][mskpsel]
                )
                x = (
                    22.5
                    - 2.5 * np.log10(assign["FLUX_" + band][msksel])
                    - exts[band] * assign["EBV"][msksel]
                )
                ax.set_xlabel(
                    "22.5 - 2.5*log10(FLUX_{}) - {:.3f} * EBV".format(band, exts[band])
                )
            # AR if no ls-dr9 flux, we try gaia_g
            elif ((np.isfinite(parent["GAIA_PHOT_G_MEAN_MAG"])) & (mskpsel)).sum() > 0:
                dohist = 1
                xp = parent["GAIA_PHOT_G_MEAN_MAG"][mskpsel]
                x = assign["GAIA_PHOT_G_MEAN_MAG"][msksel]
                ax.set_xlabel("GAIA_PHOT_G_MEAN_MAG")
            if dohist == 1:
                plot_hist(ax, x, xp, msk)
                _, ymax = ax.get_ylim()
                ax.set_ylim(0.8, 100 * ymax)
                ax.set_yscale("log")

            # AR color-color diagram
            gridsize = 20
            for iy, xbands, ybands, xlim, ylim in zip(
                [2, 3],
                [("R", "Z"), ("R", "Z")],
                [("G", "R"), ("R", "W1")],
                [(-0.5, 2.5), (-0.5, 2.5)],
                [(-0.5, 2.5), (-2, 5)],
            ):
                keep = np.ones(len(parent["TARGETID"]), dtype=bool)
                for band in [xbands[0], xbands[1], ybands[0], ybands[1]]:
                    keep &= parent["FLUX_{}".format(band)] > 0
                if keep.sum() == 0:
                    continue
                ax = plt.subplot(gs[ix, iy])
                xp = (
                    -2.5
                    * np.log10(
                        parent["FLUX_{}".format(xbands[0])]
                        / parent["FLUX_{}".format(xbands[1])]
                    )
                    - (exts[xbands[1]] - exts[xbands[0]]) * parent["EBV"]
                )
                yp = (
                    -2.5
                    * np.log10(
                        parent["FLUX_{}".format(ybands[0])]
                        / parent["FLUX_{}".format(ybands[1])]
                    )
                    - (exts[ybands[1]] - exts[ybands[0]]) * parent["EBV"]
                )
                x = (
                    -2.5
                    * np.log10(
                        assign["FLUX_{}".format(xbands[0])]
                        / assign["FLUX_{}".format(xbands[1])]
                    )
                    - (exts[xbands[1]] - exts[xbands[0]]) * assign["EBV"]
                )
                y = (
                    -2.5
                    * np.log10(
                        assign["FLUX_{}".format(ybands[0])]
                        / assign["FLUX_{}".format(ybands[1])]
                    )
                    - (exts[ybands[1]] - exts[ybands[0]]) * assign["EBV"]
                )
                # AR cutting on the relevant tracer
                xp = xp[mskpsel]
                yp = yp[mskpsel]
                x = x[msksel]
                y = y[msksel]
                # AR parent
                hbp = ax.hexbin(
                    xp,
                    yp,
                    C=None,
                    gridsize=gridsize,
                    extent=(xlim[1], xlim[0], ylim[0], ylim[1]),
                    mincnt=0,
                    visible=False,
                )
                # AR assigned
                hb = ax.hexbin(
                    x,
                    y,
                    C=None,
                    gridsize=gridsize,
                    extent=(xlim[1], xlim[0], ylim[0], ylim[1]),
                    mincnt=0,
                    visible=False,
                )
                # AR restricting to pixels with some parent data$
                keep = hbp.get_array() > 0
                #keep = np.ones(len(hbp.get_array()), dtype=bool)
                tmpx = hb.get_offsets()[keep, 0]
                tmpy = hb.get_offsets()[keep, 1]
                tmpc = hb.get_array()[keep]
                tmpcp = hbp.get_array()[keep].astype(float)
                # AR fraction assigned, clipped to famin,famax
                c = cm(np.clip(((tmpc / tmpcp) - famin) / (famax - famin), 0, 1))
                # AR transparency = f(nb of parent obj)
                tmpmin, tmpmax = (
                    1,
                    1.2 * tmpcp.sum() / float(len(hbp.get_array())),
                )
                c[:, 3] = np.clip((tmpcp - tmpmin) / (tmpmax - tmpmin), 0, 1)
                SC = ax.scatter(tmpx, tmpy, c=c, s=15,)
                SC.cmap = cm
                ax.set_xlabel("{} - {}".format(xbands[0].lower(), xbands[1].lower()))
                ax.set_ylabel("{} - {}".format(ybands[0].lower(), ybands[1].lower()))
                ax.set_xlim(xlim)
                ax.set_ylim(ylim)
                ax.grid(True)
                ax.text(
                    0.5,
                    0.93,
                    msk,
                    color="k",
                    fontweight="bold",
                    fontsize=10,
                    ha="center",
                    transform=ax.transAxes,
                )
                cbar = plt.colorbar(SC)
                cbar.set_label("fraction assigned")
                cbar.mappable.set_clim(famin, famax)

            # AR position in tile
            gridsize = 10
            ax = plt.subplot(gs[ix, 4])  # AR will be over-written
            xlim, ylim, gridsize = (rdlim, -rdlim), (-rdlim, rdlim), 50
            plot_area = (xlim[0] - xlim[1]) * (
                ylim[1] - ylim[0]
            )  # AR area of the plotting window in deg2
            # AR parent
            ax = plt.subplot(gs[ix, 4])
            plot_cutout(
                ax,
                img,
                rdlim,
                dra["parent"][mskpsel],
                ddec["parent"][mskpsel],
                pet=True,
                txts=[
                    msk,
                    "parent : {:.0f}".format(mskpsel.sum() / tarea) + r" deg$^{-2}$",
                ],
                xtxts=[0.5, 0.5],
                ytxts=[0.98, 0.1],
            )
            hbp = ax.hexbin(
                dra["parent"][mskpsel],
                ddec["parent"][mskpsel],
                C=None,
                gridsize=gridsize,
                extent=(xlim[1], xlim[0], ylim[0], ylim[1]),
                mincnt=0,
                visible=False,
            )
            # AR assigned
            ax = plt.subplot(gs[ix, 5])
            plot_cutout(
                ax,
                img,
                rdlim,
                dra["assign"][msksel],
                ddec["assign"][msksel],
                pet=True,
                txts=[
                    msk,
                    "assigned : {:.0f}".format(msksel.sum() / tarea) + r" deg$^{-2}$",
                ],
                xtxts=[0.5, 0.5],
                ytxts=[0.98, 0.1],
            )
            hb = ax.hexbin(
                dra["assign"][msksel],
                ddec["assign"][msksel],
                C=None,
                gridsize=gridsize,
                extent=(xlim[1], xlim[0], ylim[0], ylim[1]),
                mincnt=0,
                visible=False,
            )
            #
            tmpx = hb.get_offsets()[:, 0]
            tmpy = hb.get_offsets()[:, 1]
            c = hb.get_array() / hbp.get_array()
            keep = (hbp.get_array() > 0) & (c > 0)
            tmpx, tmpy, c = tmpx[keep], tmpy[keep], c[keep]
            txts = [msk, r"mean = {:.2f}".format(fafrac)]
            xtxts = [0.5, 0.5]
            ytxts = [0.93, 0.03]

            # AR assigned fraction
            ax = plt.subplot(gs[ix, 6])
            x = dra["parent"][mskpsel]
            y = ddec["parent"][mskpsel]
            C = np.in1d(parent["TARGETID"][mskpsel], assign["TARGETID"][msksel])
            gridsize = 30
            hb = ax.hexbin(
                x,
                y,
                C=C,
                gridsize=gridsize,
                extent=(xlim[1], xlim[0], ylim[0], ylim[1]),
                mincnt=1,
                alpha=0.5,
            )
            hb.cmap = cm
            # SC = ax.scatter(
            #    tmpx, tmpy, c=c, s=3, vmin=famin, vmax=famax, alpha=0.5, cmap=cm,
            # )
            ax.set_xlabel(r"$\Delta$RA [deg.]")
            ax.set_ylabel(r"$\Delta$DEC [deg.]")
            ax.set_xlim(xlim)
            ax.set_ylim(ylim)
            ax.grid(True)
            for txt, xtxt, ytxt in zip(txts, xtxts, ytxts):
                ax.text(
                    xtxt,
                    ytxt,
                    txt,
                    color="k",
                    fontweight="bold",
                    fontsize=10,
                    ha="center",
                    transform=ax.transAxes,
                )
            cbar = plt.colorbar(hb)
            cbar.set_label("fraction assigned")
            cbar.mappable.set_clim(famin, famax)
            #
            ix += 1

        #  AR saving plot
        plt.savefig(
            mytmpouts["png"], bbox_inches="tight",
        )
        plt.close()

    # AR do clean?
    if args.doclean == "y":
        log.info("")
        log.info("")
        log.info(
            "{:.1f}s\tdoclean\tTIMESTAMP={}".format(time() - start, Time.now().isot)
        )
        for key in ["tiles", "sky", "gfa", "targ", "scnd", "too", "fba"]:
            if os.path.isfile(mytmpouts[key]):
                os.remove(mytmpouts[key])
                log.info(
                    "{:.1f}s\tdoclean\tdeleting file {}".format(
                        time() - start, mytmpouts[key]
                    )
                )

    # AR move tmpoutdir -> args.outdir
    if domove:
        log.info("")
        log.info("")
        log.info(
            "{:.1f}s\tdomove\tTIMESTAMP={}".format(time() - start, Time.now().isot)
        )
        # AR optional files
        if args.doclean == "n":
            for key in ["tiles", "sky", "gfa", "targ", "scnd", "too", "fba"]:
                if os.path.isfile(mytmpouts[key]):
                    _ = shutil.move(mytmpouts[key], myouts[key])
                    log.info(
                        "{:.1f}s\tdomove\tmoving file {} to {}".format(
                            time() - start, mytmpouts[key], myouts[key]
                        )
                    )
                else:
                    log.info(
                        "{:.1f}s\tdomove\tno file {}".format(
                            time() - start, mytmpouts[key]
                        )
                    )
        # AR svn-checked files
        for key in ["fiberassign", "png"]:
            _ = shutil.move(mytmpouts[key], myouts[key])
            log.info(
                "{:.1f}s\tdomove\tmoving {} to {}".format(
                    time() - start, mytmpouts[key], myouts[key]
                )
            )
        key = "log"
        log.info(
            "{:.1f}s\tdomove\tmoving {} to {}".format(
                time() - start, mytmpouts[key], myouts[key]
            )
        )
        # AR and we re done
        log.info("")
        log.info("")
        log.info("{:.1f}s\tend\tTIMESTAMP={}".format(time() - start, Time.now().isot))


if __name__ == "__main__":

    # AR to speed up development/debugging
    dotile, dosky, dogfa, dostd, domtl, doscnd, dotoo, dofa, dozip, doplot, domove = (
        False,
        False,
        False,
        False,
        False,
        False,
        False,
        False,
        False,
        False,
        False,
    )
    dotile = True
    dosky = True
    dogfa = True
    dostd = True
    domtl = True
    doscnd = True
    dotoo = True
    dofa = True
    dozip = True
    doplot = True
    domove = True

    # AR reading arguments
    parser = ArgumentParser()
    parser.add_argument(
        "--outdir", help="output directory", type=str, default=None, required=True,
    )
    parser.add_argument(
        "--tileid",
        help="output TILEID (e.g., 63142)",
        type=int,
        default=None,
        required=True,
    )
    parser.add_argument(
        "--forcetileid",
        help="y/n, if y, allows to generate tileids which already exist in svn (default=n)",
        type=str,
        default="n",
        required=False,
        choices=["y", "n"],
    )
    parser.add_argument(
        "--tilera", help="tile centre ra", type=float, default=None, required=True,
    )
    parser.add_argument(
        "--tiledec", help="tile centre dec", type=float, default=None, required=True,
    )
    parser.add_argument(
        "--survey",
        help="survey",
        type=str,
        default=None,
        required=True,
        choices=["sv2", "sv3"],
    )
    parser.add_argument(
        "--program",
        help="program",
        type=str,
        default=None,
        required=True,
        choices=["DARK", "BRIGHT", "BACKUP"],
    )
    parser.add_argument(
        "--goaltime",
        help="goal effective time (default for sv2: {})".format(
            ", ".join(
                [
                    "{}={}".format(key, goaltimes_all["sv2"][key])
                    for key in ["DARK", "BRIGHT", "BACKUP"]
                ]
            )
        ),
        type=float,
        default=None,
        required=False,
    )
    parser.add_argument(
        "--sbprof",
        help="surface brightness profile to be used for computing time -> efftime relation (default for sv2: {})".format(
            ", ".join(
                [
                    "{}={}".format(key, sbprofs_all["sv2"][key])
                    for key in ["DARK", "BRIGHT", "BACKUP"]
                ]
            )
        ),
        type=str,
        default=None,
        required=False,
        choices={"ELG, BGS, PSF, FLT"},
    )
    parser.add_argument(
        "--mintfrac",
        help="minimum exposure time fraction needed for this tile to be considered done (default=0.9)",
        type=float,
        default=0.9,
        required=False,
    )
    parser.add_argument(
        "--rundate",
        help="yyyy-mm-ddThh:mm:ss+00:00 rundate for focalplane with UTC timezone formatting (default=current UTC time)",
        type=str,
        default=None,
        required=False,
    )
    parser.add_argument(
        "--mtltime",
        help="yyyy-mm-ddThh:mm:ss+00:00 MTL isodate, with UTC timezone formatting (default=current UTC time)",
        type=str,
        default=None,
        required=False,
    )
    parser.add_argument(
        "--standards_per_petal",
        help="required number of standards per petal (default=10)",
        type=str,
        default="10",
        required=False,
    )
    parser.add_argument(
        "--sky_per_petal",
        help="required number of sky targets per petal (default=40)",
        type=str,
        default="40",
        required=False,
    )
    parser.add_argument(
        "--sky_per_slitblock",
        help="Required number of sky targets per fiber slitblock",
        type=int,
        default=1,
        required=False,
    )
    parser.add_argument(
        "--dr",
        help="legacypipe dr (default=dr9)",
        type=str,
        default="dr9",
        required=False,
        choices=["dr9"],
    )
    parser.add_argument(
        "--gaiadr",
        help="gaia dr (default=gaiadr2)",
        type=str,
        default="gaiadr2",
        required=False,
        choices=["gaiadr2"],
    )
    parser.add_argument(
        "--dtver",
        help="desitarget catalogue version",
        type=str,
        default=None,
        required=True,
    )
    parser.add_argument(
        "--pmcorr",
        help="apply proper-motion-correction before fiber assignment? (y/n) (default=n)",
        type=str,
        default="n",
        required=False,
    )
    parser.add_argument(
        "--pmtime_utc_str",
        help="yyyy-mm-ddThh:mm:ss+00:00, UTC time use to compute new coordinates after applying proper motion since REF_EPOCH (default=current UTC time)",
        type=str,
        default=None,
        required=False,
    )
    parser.add_argument(
        "--doclean",
        help="delete TILEID-{tiles,sky,std,gfa,targ,scnd,too}.fits files (y/n)",
        type=str,
        default="n",
        required=False,
    )
    parser.add_argument(
        "--log-stdout",
        action='store_true',
        help="log to stdout instead of redirecting to a file",
        )
    #
    args = parser.parse_args()
    log = Logger.get()
    start = time()

    # AR safe: outdir
    if args.outdir[-1] != "/":
        args.outdir += "/"
    if os.path.isdir(args.outdir) == False:
        os.mkdir(args.outdir)

    # AR utc_time_now, rundate, pmtime
    utc_time_now = datetime.now(tz=timezone.utc)
    utc_time_now_str = utc_time_now.isoformat(timespec='seconds')
    mjd_now = Time(utc_time_now).mjd
    if args.rundate is None:
        args.rundate = utc_time_now_str
    if args.mtltime is None:
        args.mtltime = utc_time_now_str
    if args.pmtime_utc_str is None:
        args.pmtime_utc_str = utc_time_now_str

    # AR goaltime
    if args.goaltime is None:
        args.goaltime = goaltimes_all[args.survey][args.program]

    # AR sbprof
    if args.sbprof is None:
        args.sbprof = sbprofs_all[args.survey][args.program]

    # AR create a temporary directory for generated files
    tmpoutdir = tempfile.mkdtemp()

    if tmpoutdir[-1] != "/":
        tmpoutdir += "/"

    # AR output files
    myouts = {}
    #
    for key in ["tiles", "sky", "gfa", "targ", "scnd", "too"]:
        myouts[key] = os.path.join(
            args.outdir, "{:06d}-{}.fits".format(args.tileid, key)
        )
    myouts["fba"] = os.path.join(args.outdir, "fba-{:06d}.fits".format(args.tileid))
    myouts["fiberassign"] = os.path.join(
        args.outdir, "fiberassign-{:06d}.fits".format(args.tileid)
    )
    myouts["png"] = os.path.join(
        args.outdir, "fiberassign-{:06d}.png".format(args.tileid)
    )
    myouts["log"] = os.path.join(
        args.outdir, "fiberassign-{:06d}.log".format(args.tileid)
    )

    # AR temporary output files
    mytmpouts = {}
    for key in list(myouts.keys()):
        mytmpouts[key] = myouts[key].replace(args.outdir, tmpoutdir)

    # AR temporary log file
    if os.path.isfile(mytmpouts["log"]):
        os.remove(mytmpouts["log"])
    if args.log_stdout:
        main()
    else:
        with stdouterr_redirected(to=mytmpouts["log"]):
            main()

        # AR/SB moving the log at last if it was sent to a file
        _ = shutil.move(mytmpouts["log"], myouts["log"])

    # AR deleting folder if empty
    tmpfiles = os.listdir(tmpoutdir)
    if len(tmpfiles) == 0:
        os.rmdir(tmpoutdir)
    else:
        log.error('temp directory not empty: {}'.format(tmpfiles))
